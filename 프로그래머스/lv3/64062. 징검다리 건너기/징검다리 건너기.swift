import Foundation

/**
1. 문제 파악: 최적화 문제(최대 칸수 k가 매개변수로 주어질 때, 징검다리를 건널 수 있는 최대 명수)
2. 일단 예제를 가지고 단계를 파악해보자

k = 3 : 최대 건너뛸 수 있는 칸 수

stones: 2 4 5 3 2 1 4 2 5 1

1명 o  : 1 3 4 2 1 0 3 1 4 0
2명 o  : 0 2 3 1 0 0 2 0 3 0 -> 다음 건너는 칸부터 0이 K만큼 연속되게 등장하는 순간 현재 사람은 다리를 건널 수 없음
3명 o  : 0 1 2 0 0 0 1 0 2 0
4명?   : 0 0 1 -----         -> 4명 이후부터는 못건넘

3. 규칙, 아이디어?
-> 다음 건너는 칸부터 0이 K만큼 연속되게 등장하는 순간 현재 사람은 다리를 건널 수 없음
-> K보다 작거나 같은 칸이 K개 연속으로 있으면 다리를 못 건넘
-> K보다 작거나 같은 칸이 K개 연속으로 있지 않으면 다리를 건넘
-> 잠깐, 최대로 건널 수 있는것은 결국에 최대 숫자까지인가?

K = 10
1명 o  : 1 3 4 2 1 0 3 1 4 0
2명 o  : 0 2 3 1 0 0 2 0 3 0
3명 o  : 0 1 2 0 0 0 1 0 2 0
4명?   : 0 0 1 0 0 0 0 0 1 0
5명    : 0 0 0 0 0 0 0 0 0 0 -> 5명까지 건널 수 있음 => 왜냐하면 5보다 작은 값은 결국 다 지워지니까 => max는 돌 중에 가장 큰수로 정하면 됨

200,000,000억 -> 로그n 연산 -> 대략16정도..?

4. 설계
- 최대범위 돌중에 최대 큰 수(ex. 5)
- 건널 수 있는가 체크

    - 1) 명 수 : 이분 탐색
    - 2) 건널 수 있는 지 체크 = 연속된 0의 개수 : stones.count만큼 O(n)으로 계산 가능
*/

func solution(_ stones:[Int], _ k:Int) -> Int {
    
    // st, en를 1 ~ stones.max()!로 정했음
    // 무조건 1명은 건널 수 있어
    // 최대 stones.max()! 만큼의 사람이 다리를 건널 수 있음
    var (st, en) = (1, 200_000_000)
    
    // O(lg(2억)) => 16
    while st <= en {
        let mid = (st + en) / 2
        var zeros = 0 // 연속된 0의 카운트
        var len = 0   // 끝까지 갔을 때 연속된 구간의 최대 길이는 얼마인가

        // O(stones.count) = O(200,000)
        for i in stones.indices {
            if stones[i] <= mid {
                zeros += 1
            } else {
                len = max(len, zeros)
                zeros = 0
            }
        }
        
        // 마지막에 나왔을때도 담아주기
        len = max(len, zeros)
        
        if len >= k {   // 못 건너니까 사람 수 줄여
            en = mid - 1
        } else {        // 건널 수 있으니까 사람 수 늘려
            st = mid + 1
        }
    }
    
    return st
}